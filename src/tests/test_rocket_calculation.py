import unittest
from unittest.mock import patch

import os 
import pygame
import math
import numpy as np
os.environ["SDL_VIDEODRIVER"] = "dummy"

from ..helpers.rocket import RocketCalculation


class TestRocket(unittest.TestCase):
    @classmethod
    def setupClass(cls):
        pygame.init()

    @classmethod
    def tearDownClass(cls):
        pygame.quit()

    def setUp(self) -> None:
        self.rocket = RocketCalculation()
        self.rocket.set_constants({}, {}, {}, {}, pygame.Rect(0,0,0,0))
        self.rocket.set_variables()
    
    def test_drag_from_wind(self):
        self.rocket.air_density = 1.225
        self.rocket.drag_coeff = 0.5
        self.rocket.size = pygame.Vector2(20, 100)
        self.rocket.rocket_angle = 0
        self.rocket.wind_velocity = np.array([
            10 * np.cos(np.radians(45)),
            10 * np.sin(np.radians(45))
        ])
        self.rocket.velocity = np.array([0, 300])

        expected_drag = (1/2) * self.rocket.air_density * np.power(np.linalg.norm(self.rocket.velocity - self.rocket.wind_velocity), 2) * self.rocket.drag_coeff * (np.pi*((self.rocket.size.x/2)**2))

        self.assertAlmostEqual(self.rocket.get_drag_from_wind, expected_drag, places=6, msg=f"Drag generated by wind")

    def test_torque_generated_by_wind(self):
        def test():
            lever_arm = np.linalg.norm(self.rocket.center_of_mass - self.rocket.center_of_pressure)
            relative_velocity = np.linalg.norm(self.rocket.velocity - self.rocket.wind_velocity)
            cross_sectional_area = np.pi*np.power(self.rocket.size.x/2,2)
            drag = 0.5 * self.rocket.air_density * np.power(relative_velocity, 2) * 0.5 * cross_sectional_area
            return drag * lever_arm

        self.rocket.air_density = 1.225
        self.rocket.drag_coeff = 0.5
        self.rocket.size = pygame.Vector2(20, 100)
        self.rocket.rocket_angle = 0
        self.rocket.wind_velocity = np.array([
            10 * np.sin(np.radians(45)),
            10 * np.cos(np.radians(45))
        ])
        self.rocket.velocity = np.array([0, 300])

        self.rocket.center_of_mass = np.array([self.rocket.size.x/2, self.rocket.size.y/2])
        self.rocket.center_of_pressure = np.array([self.rocket.center_of_mass[0], self.rocket.center_of_mass[1]+20])

        # formula right
        expected_torque = test()
        self.assertAlmostEqual(self.rocket.get_torque_generated_by_wind, expected_torque, places=1, msg="Torque generated by wind")

    def test_torque_generated_by_thrust(self):
        self.rocket.size = pygame.Vector2(20, 100)
        self.rocket.center_of_mass = pygame.Vector2(self.rocket.size.x/2, self.rocket.size.y/2)
        self.rocket.force_thrust = 10000
        self.rocket.thrust_angle = 5
        self.rocket.thrust_position =  pygame.Vector2(self.rocket.center_of_mass.x, self.rocket.size.y)

        self.assertAlmostEqual(self.rocket.get_torque_generated_by_thrust, 43577.871373829086779032135418737, places=6)
    
    def test_inertia(self):
        self.rocket.size = pygame.Vector2(20, 100)
        self.rocket.dry_mass = 1000
        self.rocket.fuel_mass = 0

        expected_inertia = (1/12) * (self.rocket.dry_mass + self.rocket.current_fuel) * (3*np.power(self.rocket.size.x/2, 2) + np.power(self.rocket.size.y, 2))

        self.assertAlmostEqual(self.rocket.get_inertia, expected_inertia, places=6, msg="Inertia of the rocket")


if __name__ == "__main__":
    unittest.main()


# center of mass
# center of pressure
# tests
# stand rocket

# after all the tests, test the game AND CODE A LOT, A LOT. 
# change also center of pressure of the rocket based on the wind