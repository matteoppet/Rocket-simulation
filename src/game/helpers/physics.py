import numpy as np
import pygame


class Physics:
    """ A class that simulates physics.

        Components (variables to pass to each functions):
            Attributes (each component):
                Name (str): The name of the object
                Mass (float): The mass of the object
                Size (Vector): The size of the object
                Position (array): The position of the object
                Shape (str): The shape of the object
                Angle (float): The angle of the object, in degrees
                Local_offset (array): The offset of the object (if the object is unique, offset is 0, otherwise the distance from the main component)
        
        Methods:
            __init__(self, rocket_instance, environment): Initializes the rocket main class, and the main environment class
            apply(self, components, thrust, motor): Apply the physics to the rocket/object
            get_center_of_pressure(self, components): Calculates the Center of Pressure of the rocket/object
            get_center_of_gravity(self, components): Calculates the Center of Gravity of the rocket/object
            get_drag(self, components): Calculates the Drag of the rocket/object
            get_cross_sectional_area(self, components): Calculates the Cross-Sectional-Area of the rocket/object, even of the fins
            get_lift(self, components): Calculates the lift of the rocket/object
            get_thrust_vector(self, components): Splits the thrust into horizontal and vertical based on the angle of the rocket/object
            torque_wind(self, components): Calculates the torque generated by the wind, get from the environment instance (class)
            torque_thrust(self, components): Calculates the torque generated by the thrust, the thrust vector is based on the gimbal angle of the motor
            get_inertia(self, components): Calculates the inertia of the rocket/object
            get_weight(self, components): Calculates the weight acting on the rocket/object including the gravity got from the environment instance (class) (gravity changes with altitude)
            get_relative_velocity(self, components): Gets the difference on velocity between the rocket/object and the wind
            get_total_torque(self, components): Returns the sum of the torque from the wind and the thrust, if there is no motor on the rocket/object, it returns only the torque from the wind
     """

    def __init__(self, rocket_instance: classmethod = None, environment: classmethod = None):
        self.environment = environment
        self.rocket_instance = rocket_instance

    def apply(self, components: list, thrust: np.asarray, motor: pygame.sprite.Sprite | None, colliding: bool) -> tuple:
        self.thrust = thrust
        self.motor = motor

        total_mass = 0
        for component in components:
            total_mass += component.mass

        if colliding: 
            net_force = self.get_thrust_vector(components)
        else:
            net_force = self.get_thrust_vector(components) - self.get_weight(components) - self.get_drag(components) - self.get_lift(components)

        acceleration = net_force / total_mass
        angular_acceleration = self.get_total_torque(components) / self.get_inertia(components)

        return acceleration, angular_acceleration

    def get_center_of_pressure(self, components: list) -> np.ndarray:
        temp_data_components = {}
        total_moment = 0
        total_effective_aerodynamic_force = 0

        for component in components:
            if component.shape == "cylinder":
                radius = component.size.x/2
                area = 2*np.pi*radius*component.size.y
                local_offset_cg = component.size.y/2
                normal_fc = 0.2
            elif component.shape == "cone": 
                radius = component.size.x/2
                slant_height = np.sqrt(radius**2 + component.size.y**2)
                area = np.pi*radius*slant_height
                local_offset_cg = component.size.y/3
                normal_fc = 0.6
            else:
                raise ValueError(f"Unknown shape: {component.shape}")
            
            local_offset_cg_from_nose = component.local_offset.y+local_offset_cg
            temp_data_components[component.name] = {
                "area": area,
                "normal_fc": normal_fc,
                "offset_cg_from_nose": local_offset_cg_from_nose
            }
            
        for component, temp_data in temp_data_components.items():
            contribution = temp_data["area"] * temp_data["normal_fc"] * temp_data["offset_cg_from_nose"]
            total_moment += contribution
            total_effective_aerodynamic_force += temp_data["area"] * temp_data["normal_fc"]

        if total_effective_aerodynamic_force != 0: return np.array([0, total_moment/total_effective_aerodynamic_force])
        else: raise ValueError("Total aerodynamic force is zero, could not process the CoP calculation")

    def get_center_of_gravity(self, components: list) -> np.ndarray:
        calculation_each_component = 0
        total_mass = 0
        diameter_body = 0
        for component in components:
            if component.shape == "cone": 
                if component.name == "nose":
                    cg_component = component.local_offset.y + component.size.y/4
                else:
                    cg_component = component.local_offset.y + component.size.y/2
            elif component.shape == "cylinder":
                cg_component = component.local_offset.y + component.size.y/2
            else:
                raise ValueError(f"Unknown shape: {component.shape}")
            
            total_mass += component.mass
            calculation_each_component += component.mass * cg_component
            diameter_body = component.size.x/2
        cg_position = calculation_each_component / total_mass
        return np.array([diameter_body, cg_position])
    
    def get_drag(self, components: list) -> list:
        air_density = self.environment.get_air_density(self.rocket_instance.get_altitude(components[0].position[1]))
        speed = np.linalg.norm(self.get_relative_velocity(components))
        cross_sectional_area = self.get_cross_sectional_area(components)
        drag_coeff = 0.6 # TODO: Change

        drag_magnitude = 0.5 * drag_coeff * cross_sectional_area * air_density * (speed**2)
        drag_direction = components[0].velocity / speed if speed > 0 else np.array([0.0,0.0])
        drag = drag_direction * drag_magnitude
        return drag

    def get_cross_sectional_area(self, components: list) -> float:
        fins = None
        for component in components:
            if component.name == "fins": 
                number_fins = 4 # TODO: Change
                thickness, height = component.size
                break

        main_area = np.pi*(components[0].size.x/2)**2

        if fins: return main_area * (number_fins * thickness * height)
        else: return main_area

    def get_lift(self, components: list) -> float:
        fins = None
        for component in components:
            if component == "fins":
                aspect_ratio_fins = component.size.y / component.size.x
                fin_efficiency_factor = 2/(1+np.sqrt(1+(aspect_ratio_fins/2)))
                break
        
        air_density = self.environment.get_air_density(self.rocket_instance.get_altitude(components[0].position[1]))
        relative_velocity = self.get_relative_velocity(components)
        angle_of_attack = self.rocket_instance.get_aoa(components[0])
        cross_sectional_area = self.get_cross_sectional_area(components)

        if fins:
            lift_coeff = min((fin_efficiency_factor*np.radians(angle_of_attack)), 2.0)
        else:
            lift_coeff = 0.6 # TODO: Change

        lift = 0.5 * air_density * relative_velocity**2 * lift_coeff * cross_sectional_area
        return lift
    
    def get_thrust_vector(self, components: list) -> np.ndarray:
        return np.array([
            self.thrust * np.sin(np.radians(-components[0].angle)),
            self.thrust * np.cos(np.radians(-components[0].angle))
        ])

    def torque_wind(self, components: list) -> float:
        lever_arm = self.get_center_of_gravity(components) - self.get_center_of_pressure(components)
        wind_vector = self.environment.get_wind_velocity_vector
        return np.cross(lever_arm, wind_vector)
    
    def torque_thrust(self, components: list) -> float:
        thrust_vector = np.array([
            self.thrust * np.sin(np.radians(-self.motor.angle)),
            self.thrust * np.cos(np.radians(-self.motor.angle))
        ])
        local_offset = self.motor.local_offset
        lever_arm = self.get_center_of_gravity(components) - local_offset
        return np.cross(lever_arm, thrust_vector)
    
    def get_inertia(self, components: list) -> float:
        total_inertia = 0
        for component in components:
            if component.shape == "cylinder":
                inertia = 0.5 * component.mass * component.size.y * (component.size.x/2)**2
            elif component.shape == "cone":
                inertia = (3/10) * component.mass * (component.size.x/2)**2

            total_inertia += inertia

        return total_inertia
    
    def get_weight(self, components: float) -> np.ndarray:
        total_mass = 0
        for component in components:
            total_mass += component.mass

        return np.array([0, total_mass * self.environment.get_gravity(self.rocket_instance.get_altitude(components[0].position[1]))])
    
    def get_relative_velocity(self, components: list) -> np.ndarray:
        return components[0].velocity - self.environment.get_wind_velocity_vector

    def get_total_torque(self, components: list) -> float:
        if self.motor:
            return self.torque_wind(components) + self.torque_thrust(components)
        else:
            return self.torque_wind(components)
